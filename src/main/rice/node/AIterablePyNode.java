package main.rice.node;

import main.rice.obj.AIterablePyObj;
import main.rice.obj.APyObj;

import java.util.ArrayList;
import java.util.HashSet;
import java.util.List;
import java.util.Set;

/**
 * An abstract class whose instances represent generators for iterable Python objects
 * (list, tuple, set, or string). Includes common functionality for generating
 * permutations, though some of the individual sub-classes need to do their own
 * post-processing.
 *
 * @param <InnerType> the type of object generated by the leftChild node, which represents
 *                    the type of elements in this iterable object; if we invoke
 *                    this.leftChild.genExVals(), it will return a Set<InnerType>
 */
public abstract class AIterablePyNode<OuterType extends AIterablePyObj<InnerType>,
    InnerType extends APyObj> extends APyNode<OuterType> {

    /**
     * Overrides the leftChild in the superclass (APyNode) with a more specific type: a
     * generator of InnerType objects.
     */
    protected APyNode<InnerType> leftChild;

    /**
     * @return the left child node
     */
    @Override
    public APyNode<InnerType> getLeftChild() {
        return this.leftChild;
    }

    /**
     * Generates all valid OuterType objects within the exhaustive domain; begins by
     * generating all valid elements, and then finds all permutations of them of valid
     * length (as constrained by the exhaustive domain).
     *
     * @return a set of OuterTypes comprising the exhaustive domain
     */
    @Override
    public Set<OuterType> genExVals() {
        Set<InnerType> innerVals = this.leftChild.genExVals();
        return this.genPerms(innerVals);
    }

    /**
     * Generates a single valid OuterType object within the random domain; begins by
     * randomly generating a valid length (as constrained by the random domain), and then
     * randomly generates valid elements.
     *
     * @return a single OuterType object selected from the random domain
     */
    @Override
    public OuterType genRandVal() {
        // Randomly select the size, n
        int length = this.ranDomainChoice().intValue();

        // Randomly select n inner values
        List<InnerType> list = new ArrayList<>();
        for (int idx = 0; idx < length; idx++) {
            InnerType childVal = this.genRandInnerVal();
            list.add(childVal);
        }
        return this.genObj(list);
    }

    /**
     * Helper function for generating one random InnerType object.
     *
     * @return a randomly-generated object of type InnerType
     */
    protected InnerType genRandInnerVal() {
        return this.leftChild.genRandVal();
    }

    /**
     * Helper function for generating an object of the correct OuterType; will be
     * overridden in the subclasses, where the OuterType is known.
     *
     * @param innerVals the elements to be contained by the generated object
     * @return an OuterType object encapsulating the innerVals
     */
    protected abstract OuterType genObj(List<InnerType> innerVals);

    /**
     * Generates all permutations of the specified innerVals of length up to and including
     * the max value in this.exDomain.
     *
     * @param innerVals the set of values that can be contained within the iterable being
     *                  generated
     * @return all permutations of the elements in innerVals of length up to and including
     * the max value in this.exDomain
     */
    protected Set<OuterType> genPerms(Set<InnerType> innerVals) {
        // Create all lists up to (and including) the maximum length
        int maxLength = this.exDomainMax();
        Set<OuterType> valPerms = this.genPermsHelper(maxLength, innerVals);

        // Remove lists of lengths that are not found in this.domain
        Set<OuterType> finalPerms = new HashSet<>();
        for (OuterType perm : valPerms) {
            if (this.exDomain.contains(perm.getValue().size())) {
                finalPerms.add(perm);
            }
        }
        return finalPerms;
    }

    /**
     * Helper function for genListPerms; generates all permutations of the specified
     * innerVals of length up to and including the input size.
     *
     * @param size      the max size permutation to be generated
     * @param innerVals the set of values that can be contained within the iterable being
     *                  randomly-generated
     * @return all permutations of innerVals up to and including the max size
     */
    private Set<OuterType> genPermsHelper(int size,
        Set<InnerType> innerVals) {

        // BASE CASE: size 0 -> return a set containing only the empty list
        if (size == 0) {
            Set<OuterType> perms = new HashSet<>();
            perms.add(this.genObj(new ArrayList<>()));
            return perms;
        }

        // RECURSIVE CASE:
        // Get all permutations that are of length size - 1
        Set<OuterType> oneShorter = genPermsHelper(size - 1, innerVals);

        // Iterate over each shorter list, adding each possible single element to it
        Set<OuterType> perms = new HashSet<>(oneShorter);
        for (OuterType listObj : oneShorter) {
            // Extract the internal ArrayList representation
            List<InnerType> list = new ArrayList<>(listObj.getValue());
            if (list.size() < size - 1) {
                // For efficiency, let's avoid generating duplicates
                continue;
            }

            // Construct all new lists that result from adding val (a possible inner val)
            // to list
            for (InnerType val : innerVals) {
                // Make sure to clone list so as not to mutate the original
                List<InnerType> listClone = new ArrayList<>(list);
                listClone.add(val);
                perms.add(this.genObj(listClone));
            }
        }
        return perms;
    }
}
